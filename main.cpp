#include <iostream>
using namespace std;
/*
Algorithm
枚举
002:拨钟问题
查看 提交 统计 提问
总时间限制: 1000ms 内存限制: 65536kB
描述
有9个时钟，排成一个3*3的矩阵。

|-------|    |-------|    |-------|
|       |    |       |    |   |   |
|---O   |    |---O   |    |   O   |
|       |    |       |    |       |
|-------|    |-------|    |-------|
    A            B            C    

|-------|    |-------|    |-------|
|       |    |       |    |       |
|   O   |    |   O   |    |   O   |
|   |   |    |   |   |    |   |   |
|-------|    |-------|    |-------|
    D            E            F    

|-------|    |-------|    |-------|
|       |    |       |    |       |
|   O   |    |   O---|    |   O   |
|   |   |    |       |    |   |   |
|-------|    |-------|    |-------|
    G            H            I    
(图 1)
现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。



移动    影响的时钟
 
 1         ABDE
 2         ABC
 3         BCEF
 4         ADG
 5         BDEFH
 6         CFI
 7         DEGH
 8         GHI
 9         EFHI    
输入
9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。
输出
输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。
样例输入
3 3 0 
2 2 2 
2 1 2 
样例输出
4 5 8 9 
 */

int clocks[10], i[10], sum; //钟表[A-I对应1-9]，操作[A-I:每个按下的次数]，操作步数总和。

int main()
{
	for (int i = 1; i <= 9; ++i)
		cin >> clocks[i];

	// for (int j = 1; j <= 9; ++j)
	// 	cout << j << " " << clocks[j] << "\t";
	// cout << endl;

	// for (int i = 1; i <= 9; ++i)
	// 	cout << (4 - clocks[i] % 4) % 4; //clocks[i]归零要被开关控制的最少次数。

	//枚举1，2 3的移动方案，总共有4^3种状态。
	for (i[1] = 0; i[1] < 4; i[1]++)
		for (i[2] = 0; i[2] < 4; i[2]++)
			for (i[3] = 0; i[3] < 4; i[3]++)
			{
				//clock[1]的当前值为：
				//clock[1] 的状态为初始状态 + 方案1按下的次数+方案2按下的次数,
				//也即：clock[1]+i[1]+i[2]，而4 5 6的移动方案，只有4能调整clocks[1]，也即钟表A。
				//因此，将钟表A，也即clocks调整为0，4的开关方案是
				i[4] = (4 - (clocks[1] + i[1] + i[2]) % 4) % 4;
				//同理,只有5能调节钟表B
				i[5] = (4 - (clocks[2] + i[1] + i[2] + i[3]) % 4) % 4;
				//调节钟表C
				i[6] = (4 - (clocks[3] + i[2] + i[3]) % 4) % 4;
				//调节钟表D
				i[7] = (4 - (clocks[4] + i[1] + i[4] + i[5]) % 4) % 4;
				//由于9控制F是唯一的。因此，选择调节F
				i[9] = (4 - (clocks[6] + i[3] + i[5] + i[6]) % 4) % 4;
				//调节H
				i[8] = (4 - (clocks[8] + i[5] + i[7] + i[9]) % 4) % 4;
				sum = 0;
				sum += (clocks[1] + i[1] + i[2] + i[4]) % 4;
				sum += (clocks[2] + i[1] + i[2] + i[3] + i[5]) % 4;
				sum += (clocks[3] + i[2] + i[3] + i[6]) % 4;
				sum += (clocks[4] + i[1] + i[4] + i[5] + i[7]) % 4;
				sum += (clocks[5] + i[1] + i[3] + i[5] + i[7] + i[9]) % 4;
				sum += (clocks[6] + i[3] + i[5] + i[6] + i[9]) % 4;
				sum += (clocks[7] + i[4] + i[7] + i[8]) % 4;
				sum += (clocks[8] + i[5] + i[7] + i[8] + i[9]) % 4;
				sum += (clocks[9] + i[6] + i[8] + i[9]) % 4;
				if (sum == 0)
				{
					for (int j = 1; j <= 9; j++)
						while (i[j]--)
							cout << j << " ";
					return 0;
				}
			}

	return 0;
}
